\chapter{Software analysis}

In this chapter general software development approaches and practices will be confronted with
requirements posed on desired software library for Bayesian decision making. After stating these
requirements, feasibility of various programming paradigms applied to our real-world problem is
discussed. Continues brief survey of already available software whose conformance to requirements
is studied. The chapter is ended by comparison of suitable features of 3 chosen programming
languages: C++, Matlab language and Python. Emphasis is put on Python/Cython combination that was
chosen for implementation.

In whole chapter, the term \emph{user} refers to someone who uses the library in order to implement
higher-level functionality (such as simulation of dynamic systems); user is essentially
a~programmer.

\section{Requirements}

In order to formalise expectations for desired library for Bayesian estimation, following set of
requirements was developed.

Functionality: % TODO: bez indentace
\begin{itemize}
	\item Framework for working with potentially conditional {\pdfs} should be implemented
		including support for basic operations such as product and chain rule. Chain rule
		implementation should be flexible in a way that for example
		\(p(a_t,b_t|a_{t-1},b_{t-1}) = p(a_t|a_{t-1},b_t)p(b_t|b_{t-1})\) product can be
		represented.
	\item Basic Bayesian filtering methods such as Kalman and particle filter have to be present,
		plus at least one of more specialised algorithms --- marginalized particle filter or
		non-linear Kalman filter variants.
\end{itemize}

Ease of use: % TODO: ditto
\begin{itemize}
	\item Up-to-date, complete and readable API\footnote{Application Programming Interface, a set of
		rules that define how a particular library is used} documentation is required. Such
		documentation should be well understandable by someone that already understands mathematical
		background of particular algorithm.
	\item Initial barriers for installing and setting up the library should be lowest possible.
		Installing [TODO]
	\item TODO: development productivity (hezčí slovo!)
	\item The library should be platform-neutral and have to run on major server and workstation
		platforms, at least on Microsoft Windows and GNU/Linux.
	\item High level of interoperability is needed; data input/output should be straightforward as
		well as using existing solutions for accompanying tasks such as visualising the results.
\end{itemize}

Performance:

\section{Programming paradigms}

Interpreted vs. Compiled

Object-oriented, procedural and Functional

pass-by reference vs. copy-on-write (Matlab)

\section{Survey of Existing Libraries for Bayesian estimation/decision making}

Brief survey of existing libraries ... not fullfilling all requirements..

The need to implement a new one :-)

\section{C++}

BDM

 - advantages of C (speed, C prevalence (many optimised libraries, BLAS, LAPACK.., OpenMP)

 - disadvantages of C in our ``situation'' (steep learning curve, coplexity because of low-levelness
   high initial barriers (need to have compiler, libraries...), inconveniently long edit/build/test
   process)

\section{Matlab}

BDM (partially?)

 - advantages (popularity, existing toolboxes, rapid development (high-level)

 - disadv: strict copy-on-write, problematic object model (not in original design), difficulties
           interfacing existing C (F) code

\section{Python}

NumPy.... parallelisation (approaches, improvements in Py 3.2) - GIL.. Py3k

\section{Cython}

general info etc... extension types, building, ease of interfacing C (and F) code, .pxd files,
NumPy support

[citations:\cite{BehBraSel:09,Sel:09,BehBraCitDalSelSmi:11}]

\subsection{Gradual Optimisation}

how can optimisaion be approached (gradually) and why this approach is superior

integrate\_python\_cython example (``100x'' speedup for a special (very simple) case)

\subsection{Parallelisation}

integrate\_python\_cython patched with OpenMP (13x speedup in 16-core system)

prange CEP

\subsection{Pure Python mode}

About it and why it should be used in a hypothetical bayesian python library

\subsection{Limitations}

2 types:

	not-supported code (few cases, but bad, ongoing work)

	not-optimised code (much more work needed, but not hard to fix in most cases)

		- exception handling (functions returning void etc)

		- limitations of pure python mode in regards to traditional .pyx files

\section{Choice}

python/cython was choosen ...
